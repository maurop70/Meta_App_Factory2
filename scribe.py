import os
from datetime import datetime


class Scribe:
    """
    The Scribe Agent.
    Generates commercial-grade documentation for every new app.
    """
    def __init__(self):
        pass

    def document_app(self, app_path, app_name, blueprint, description):
        """Legacy method — calls generate_commercial_docs for backward compat."""
        self.generate_commercial_docs(app_path, app_name, blueprint, description)

    def generate_commercial_docs(self, app_path, app_name, blueprint, description, capabilities=None):
        """Generate a full commercial documentation suite for a new app."""
        print(f"--- Scribe: Generating Commercial Documentation Suite for '{app_name}' ---", flush=True)
        capabilities = capabilities or []

        docs_created = []

        # 1. README.md (Enhanced)
        readme = self._generate_readme(app_name, blueprint, description, capabilities)
        self._write_doc(app_path, "README.md", readme)
        docs_created.append("README.md")

        # 2. USER_GUIDE.md
        guide = self._generate_user_guide(app_name, description, capabilities)
        self._write_doc(app_path, "USER_GUIDE.md", guide)
        docs_created.append("USER_GUIDE.md")

        # 3. INSTALL.md
        install = self._generate_install_guide(app_name)
        self._write_doc(app_path, "INSTALL.md", install)
        docs_created.append("INSTALL.md")

        # 4. API_REFERENCE.md
        api_ref = self._generate_api_reference(app_name, blueprint, capabilities)
        self._write_doc(app_path, "API_REFERENCE.md", api_ref)
        docs_created.append("API_REFERENCE.md")

        # 5. LICENSE (MIT)
        license_text = self._generate_license()
        self._write_doc(app_path, "LICENSE", license_text)
        docs_created.append("LICENSE")

        # 6. CHANGELOG.md
        changelog = self._generate_changelog(app_name)
        self._write_doc(app_path, "CHANGELOG.md", changelog)
        docs_created.append("CHANGELOG.md")

        print(f"--- Scribe: {len(docs_created)} documents created: {', '.join(docs_created)} ---", flush=True)
        return docs_created

    def _write_doc(self, app_path, filename, content):
        filepath = os.path.join(app_path, filename)
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)

    def _generate_readme(self, app_name, blueprint, description, capabilities):
        cap_list = "\n".join(f"- {c}" for c in capabilities) if capabilities else "- General purpose AI agent"
        return f"""# {app_name}

> Built by **Meta App Factory** — Antigravity AI

## Overview

{description}

## Features

{cap_list}

## Quick Start

```bash
# Install dependencies
pip install -r requirements.txt

# Configure environment
cp .env.template .env
# Edit .env with your API keys

# Launch
python bridge.py
```

## Architecture

| Component | Description |
|:----------|:------------|
| `bridge.py` | API bridge — routes prompts to n8n workflows |
| `action_plan.py` | Triad Protocol plan engine |
| `ui.py` | Interactive command center (if applicable) |
| `config.json` | App configuration |

**Blueprint**: `{blueprint}`
**Backend**: N8N Workflow Engine

## Integration

```python
from bridge import call_app
result = call_app({{"prompt": "Your query here"}})
print(result)
```

## Documentation

- [User Guide](USER_GUIDE.md) — Step-by-step usage instructions
- [Installation](INSTALL.md) — Setup and deployment
- [API Reference](API_REFERENCE.md) — Function and endpoint reference
- [Changelog](CHANGELOG.md) — Version history

## License

MIT — See [LICENSE](LICENSE) for details.

---
*Auto-generated by Meta App Factory on {datetime.now().strftime('%Y-%m-%d')}*
"""

    def _generate_user_guide(self, app_name, description, capabilities):
        cap_sections = ""
        for i, cap in enumerate(capabilities or ["General querying"], 1):
            cap_sections += f"""
### {i}. {cap.title()}

To use the **{cap}** capability:

```python
from bridge import call_app
result = call_app({{"prompt": "Your {cap}-related query", "context": "{cap}"}})
print(result)
```

The system will route your request to the appropriate agent and return a structured response.

"""
        return f"""# {app_name} — User Guide

## Table of Contents

1. [Getting Started](#getting-started)
2. [Core Features](#core-features)
3. [Using the Interface](#using-the-interface)
4. [Advanced Usage](#advanced-usage)
5. [Troubleshooting](#troubleshooting)

## Getting Started

{app_name} is an AI-powered application built by the Meta App Factory.

**What it does:** {description}

### Prerequisites

- Python 3.9+
- Active n8n instance with deployed workflow
- API keys configured in `.env`

### First Launch

1. Open a terminal in the app directory
2. Run `launch_{app_name.lower().replace(' ', '_')}.bat` (Windows) or `python bridge.py` (any OS)
3. The system will connect to the n8n backend and initialize

## Core Features

{cap_sections}

## Using the Interface

### Command Center (UI)

If this app includes a UI (`ui.py`), launch it with:

```bash
python ui.py
```

**Available panels:**
- **Command Console** — Type prompts and see responses
- **Action Plan** — View and control multi-step execution plans
- **Neural Network Status** — Monitor agent availability
- **Atomizer** — Break down complex tasks

### Triad Execute

For complex tasks, use the **Triad Execute** button:

1. Type your task in the input field
2. Click **Triad Execute**
3. Review the generated Action Plan
4. Provide feedback or click **Approve Plan**
5. Click **Execute** to run the plan

## Advanced Usage

### Batch Processing

```python
from bridge import call_app
tasks = ["Task 1", "Task 2", "Task 3"]
results = [call_app({{"prompt": t}}) for t in tasks]
```

### Custom Agent Routing

```python
from bridge import call_app
# Route to a specific agent
result = call_app({{
    "prompt": "Analyze this data",
    "agent": "CFO",
    "context": "financial_analysis"
}})
```

## Troubleshooting

| Issue | Solution |
|:------|:---------|
| "Connection refused" | Verify n8n is running and webhook URL in `.env` is correct |
| Empty responses | Check API keys in `.env` |
| Slow responses | n8n may be cold-starting — wait 10-15s and retry |
| Import errors | Run `pip install -r requirements.txt` |

---
*Auto-generated by Meta App Factory on {datetime.now().strftime('%Y-%m-%d')}*
"""

    def _generate_install_guide(self, app_name):
        safe_name = app_name.lower().replace(' ', '_')
        return f"""# {app_name} — Installation Guide

## System Requirements

- **OS**: Windows 10+, macOS 12+, or Linux (Ubuntu 20.04+)
- **Python**: 3.9 or higher
- **RAM**: 4GB minimum
- **Network**: Internet access required for n8n cloud

## Quick Install

```bash
# 1. Navigate to the app directory
cd {app_name}

# 2. Install Python dependencies
pip install -r requirements.txt

# 3. Configure environment
cp .env.template .env
```

## Environment Configuration

Edit `.env` and set the following:

| Variable | Description | Required |
|:---------|:------------|:---------|
| `WEBHOOK_URL` | n8n webhook base URL | Yes |
| `GEMINI_API_KEY` | Google Gemini API key | Yes |
| `CLAUDE_API_KEY` | Anthropic Claude key | Optional |
| `OPENAI_API_KEY` | OpenAI API key | Optional |

## Deployment Options

### Option 1: Local Development

```bash
python bridge.py
```

### Option 2: Docker

```bash
docker build -t {safe_name} .
docker run -p 5000:5000 --env-file .env {safe_name}
```

### Option 3: Production (with Launch Script)

```bash
# Windows
launch_{safe_name}.bat

# Linux/macOS
chmod +x launch_{safe_name}.sh && ./launch_{safe_name}.sh
```

## Verification

After setup, verify the installation:

```bash
python -c "from bridge import call_app; print(call_app({{'prompt': 'PING'}}))"
```

Expected output: A response from the n8n workflow.

## Upgrading

```bash
git pull origin main
pip install -r requirements.txt --upgrade
```

---
*Auto-generated by Meta App Factory on {datetime.now().strftime('%Y-%m-%d')}*
"""

    def _generate_api_reference(self, app_name, blueprint, capabilities):
        return f"""# {app_name} — API Reference

## Bridge Functions

### `call_app(payload: dict) -> str`

Primary function to interact with the app.

**Parameters:**

| Parameter | Type | Description |
|:----------|:-----|:------------|
| `prompt` | `str` | The user query or instruction |
| `context` | `str` | Optional context identifier |
| `agent` | `str` | Target agent (default: auto-route) |
| `project_name` | `str` | Project scope name |

**Returns:** `str` — The agent's response text.

**Example:**

```python
from bridge import call_app

result = call_app({{
    "prompt": "Analyze Q4 revenue trends",
    "agent": "CFO"
}})
print(result)
```

### `call_with_plan_context(prompt: str) -> str`

Execute a task with full Triad Protocol context.

### `execute_plan_step(step_data: dict) -> str`

Execute a single step from an Action Plan.

## Action Plan API

### `parse_gemini_response(response: str, task: str) -> ActionPlan`

Parse a Gemini response into a structured ActionPlan.

### `execute_plan(plan: ActionPlan, bridge_fn, callback) -> None`

Execute an approved ActionPlan step by step.

### `ActionPlan.generate_mission_report() -> str`

Generate a post-execution summary with results and artifact links.

## Webhook Endpoints

**Blueprint:** `{blueprint}`

| Endpoint | Method | Description |
|:---------|:-------|:------------|
| `/webhook/<path>` | POST | Main workflow trigger |
| `/webhook/test/<path>` | POST | Test mode trigger |

**Request body:**

```json
{{
    "prompt": "Your query",
    "chatInput": "Your query",
    "input": "Your query"
}}
```

**Response:**

```json
{{
    "text": "Agent response",
    "source": "workflow_name"
}}
```

---
*Auto-generated by Meta App Factory on {datetime.now().strftime('%Y-%m-%d')}*
"""

    def _generate_license(self):
        year = datetime.now().year
        return f"""MIT License

Copyright (c) {year} Antigravity AI

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""

    def _generate_changelog(self, app_name):
        return f"""# {app_name} — Changelog

## [1.0.0] - {datetime.now().strftime('%Y-%m-%d')}

### Added
- Initial release
- Core bridge.py with self-healing and retry logic
- Action Plan engine (action_plan.py)
- N8N workflow integration
- Auto-generated documentation suite
- Launch scripts for Windows

### Architecture
- Built on Meta App Factory blueprint system
- Triad Protocol support (Gemini + Claude + Antigravity)
- OpenTelemetry instrumentation ready

---
*Maintained by Meta App Factory*
"""


if __name__ == "__main__":
    # Test
    scr = Scribe()
    scr.generate_commercial_docs(".", "TestApp", "gemini_reasoner", "A test app.", ["reasoning", "analysis"])
"""
# --- PATCH LOG ---
# [2026-02-18] Fixed UnicodeEncodeError in ui_designer.py.
# Root Cause: 'charmap' codec failure on Windows when writing unicode characters (e.g. bullets).
# Resolution: Enforced encoding='utf-8' in open() call within build_ui().
# Verified: True (Smoke Test Passed)
# [2026-02-24] Upgraded from basic README to full commercial suite (6 docs).
"""
